/*
*   Node Comunication Server
*   This is a code generated by Diego López Pajares.
*/


#include "nodo_comunicacion/nodo_comunicacion_.h"

/************************VARIABLES GLOBALES***************************/
nav_msgs::Odometry posicion_actual;//Variable global para estimar la posición en cada momento
kobuki_msgs::SensorState check_bumper_sensor;
int flag_parada=0; //Flag que se activa en caso de choque;
double orientacion_actual;
float bateryLevel;
int   chargerState;
int numberOfPicture=0;
bool stopCapture= false;
/*********************************************************************/
void imageCallback(const sensor_msgs::ImageConstPtr& msg)
{
  cv::Mat image;
  numberOfPicture++;
  std::string filename;
  char aux[40];
  sprintf(aux,"/home/gsi/Picture%d.jpg",numberOfPicture);
  filename=std::string(aux);
  std::cout<<"Picture save in: "<<filename<<"\n";
  image = cv_bridge::toCvShare(msg,"bgr8")->image;
  if(!cv::imwrite(filename,image))
  {
	printf("Error converting image to .jpg\n");
	stopCapture=true;
	numberOfPicture=-1; // set the number of picture=0 for indicates an error
	return;
  }
  stopCapture=true;
}

void odometria (const nav_msgs::Odometry posicion)
{
	//Función que obtiene la posición de las coordenadas del robot x e y, así como la orientación que tiene en ese momento.
	posicion_actual.pose.pose.position.x=double(posicion.pose.pose.position.x);
	posicion_actual.pose.pose.position.y=double(posicion.pose.pose.position.y);
	posicion_actual.pose.pose.orientation.z=double(posicion.pose.pose.orientation.z);
	if (posicion_actual.pose.pose.orientation.z<0.f)
	{
		orientacion_actual=360+((asin(posicion.pose.pose.orientation.z)-acos(posicion.pose.pose.orientation.w))*180/PI);
	}
	else
	{
		orientacion_actual=(asin(posicion.pose.pose.orientation.z)+acos(posicion.pose.pose.orientation.w))*180/PI;
	}
	if (orientacion_actual==360)
		orientacion_actual=0;
}

void bumper_sensor (const kobuki_msgs::SensorState state)
{
	///Funcion que recoge el estado del sensor de choque, si es mayor que 0, es que se ha producido un choque.
	// Para la comprobación inicial del mundo
	check_bumper_sensor=state;

}

void sensor_choque (const kobuki_msgs::BumperEvent bumperMessage)
{
	//Comprueba el sensor de choque cuando el robot está en movimiento. En caso de choque activa un flag que detendrá el robot
	if (bumperMessage.state==1)
	{
		//Se ha producido un choque
		 flag_parada=1;
	}
}

void nivel_bateria (const diagnostic_msgs::DiagnosticArray niveles)
{
	std::string aux;
	aux=niveles.status[0].values[1].value; // Read batery level form the specific topic
	bateryLevel= ::atof(aux.c_str()); // Convert into a number the level ( in %)
	aux=niveles.status[0].values[5].value;
	printf("Nivel de bateria: %f\n",bateryLevel);
	if (aux.compare("Not Charging")==0)
	{
		chargerState=0; // Not charging
	}
	else
	{
		chargerState=1; //Chargin
	}
		
}

RESULTADO *
locomotionforwardrqstandrcv_1_svc(DATOS *argp, struct svc_req *rqstp)
{
	/***********************Definicion de variables **********************************/
	static RESULTADO  result;
	DATOS datos_recibidos;	
	geometry_msgs::Twist vel; 
	ros::Publisher vel_pub_;
	ros::NodeHandle na;
	nav_msgs::Odometry posicion_inicial;
	nav_msgs::Odometry posicion_deseada;
	double orientacion_inicial;
	/****************************************************************/

	datos_recibidos=*(argp); //Recolección de los datos recibidos de Plexil en una variable.
	ros::Subscriber sub = na.subscribe("/odom", 100, odometria);//Suscripción al topic de la odometría del robot
	ros::Subscriber sub1 = na.subscribe("/mobile_base/events/bumper", 100, sensor_choque);//Suscripción al topic del sensor de choque
	vel_pub_=na.advertise<geometry_msgs::Twist>("cmd_vel_mux/input/teleop", 1);//Variable para publicar la velocidad	
	ros::Rate loop_rate(1000); //Frecuencia de realización del bucle while.	
	ros::Time ahora; // variable de tipo tiempo para almacenar el instante de tiempo.

	/*********************Se recoge la posición inicial que tiene el robot*********************************/
	ahora=ros::Time::now();	
	while(ros::Time::now()<ahora + ros::Duration(0.5))
	{
		ros::spinOnce();// Comprueba el topic de odometria para establecer la posicion inicial que tiene el robot
	}
	
	posicion_inicial.pose.pose.position.x=posicion_actual.pose.pose.position.x;
	posicion_inicial.pose.pose.position.y=posicion_actual.pose.pose.position.y;
	orientacion_inicial=orientacion_actual;
	/**********Se ajusta la velocidad de avance del robot y se hace un ajuste de la posición deseada en función de la velocidad*******/
	vel.linear.x=datos_recibidos.vel_linear;
	vel.linear.y=0;
	vel.angular.z=datos_recibidos.vel_angular;

	

	double x0=0.f; 
	double y0=0.f;
	double distancia=0.f;
	double desvio_angulo;
	distancia=double(datos_recibidos.avance);
	double tam_paso=0.f;
	x0=double(posicion_inicial.pose.pose.position.x);
	y0=double(posicion_inicial.pose.pose.position.y);
	/******************* Se avanza hasta que no se alcanza el objetivo *****************************************/
	while( distancia>=0.f)
	{
		//Bucle que comprueba la posicion y sigue avanzando hasta encontrar el objetivo
		ros::spinOnce();
		tam_paso=double(sqrt(pow((double(posicion_actual.pose.pose.position.x)-x0),2)+pow((double(posicion_actual.pose.pose.position.y)-y0),2)));
		x0=double(posicion_actual.pose.pose.position.x);
		y0=double(posicion_actual.pose.pose.position.y);
		distancia=distancia-tam_paso;
		desvio_angulo=orientacion_actual-orientacion_inicial;


			if ( distancia < 0.20 && distancia > 0.015)
			{
				if (datos_recibidos.vel_linear<0)
					vel.linear.x=-0.06;
				else
					vel.linear.x=0.06;
			}
			else if( distancia < 0.15 && distancia > 0.05)
			{
				if (datos_recibidos.vel_linear<0)
					vel.linear.x=-0.06;//-0.04; // Para que al hacer el undock no tarde tanto
				else
				vel.linear.x=0.04;
			}
			else if(distancia<=0.05f && distancia >0.03f)
			{
				if (datos_recibidos.vel_linear<0)
					vel.linear.x=-0.06;//-0.015;
				else
				vel.linear.x=0.015;
			}
			else if ( distancia<=0.03f)
			{
				if (datos_recibidos.vel_linear<0)
					vel.linear.x=-0.06;//-0.005;
				else
				vel.linear.x=0.005;
			}
			else
				vel.linear.x=datos_recibidos.vel_linear;
			// Correción de ángulo para que no pierda la dirección y avance correctamente.
			if (desvio_angulo >0.f)
			{
				if (desvio_angulo >1.f)
					vel.angular.z=0.01;
				else
					vel.angular.z=-0.01; //Valor anterior 0.01
			}
			else if (desvio_angulo <0.f)
			{
				if (desvio_angulo <-1.f)
					vel.angular.z=-0.01;
					vel.angular.z=0.01;
			}
			else
				vel.angular.z=0;
		
		if(flag_parada==1)
		{
            if(datos_recibidos.vel_linear<0)
            {
                flag_parada=0;//Si el robot va hacia detrás que no se pare, ya que lo que hace es esquivar el obstáculo.
            }
            else
            {
			//Se ha detectado un choque, por lo que se para el avance del robot
			break; //Finaliza el bucle puesto que ha ocurrrido un choque
            }
		}		
		vel_pub_.publish(vel);	
		loop_rate.sleep();
	}
	if (flag_parada==1)
	{	
		//Como ha ocurrido un choque el robot se detiene. Devuelve la posición en la que se ha detenido.
		flag_parada=0;
        vel.linear.x=0;
		vel_pub_.publish(vel);
	}
	/*********************Se recoge la posición final que tiene el robot*********************************/
	ahora=ros::Time::now();	
	while(ros::Time::now()<ahora + ros::Duration(0.5))
	{
		ros::spinOnce();
	}
	result.pos_actual_y=float(posicion_actual.pose.pose.position.y);
	result.orientacion_actual=float(orientacion_actual);
	result.pos_actual_x=float(posicion_actual.pose.pose.position.x);
	result.pos_actual_y=float(posicion_actual.pose.pose.position.y);

	/**********************************************************************************************/	
	return &result;
}

RESULTADO *
locomotionrotaterqstandrcv_1_svc(DATOS *argp, struct svc_req *rqstp)
{
	/**************************Declaracion de variables**************************************************/
	static RESULTADO  result;
	DATOS datos_recibidos;	
	geometry_msgs::Twist vel; 
	ros::Publisher vel_pub_;
	ros::NodeHandle n;
	ros::NodeHandle np;
	nav_msgs::Odometry posicion_inicial;
	nav_msgs::Odometry posicion_deseada;
	double angulo_deseado=0;
	double angulo_final=0;
	double limite_inferior=0,limite_superior=0;
	/*****************************************************************************************************/
	
	datos_recibidos=*(argp); //Recolección de los datos recibidos de Plexil en una variable.
	ros::Subscriber sub = n.subscribe("/odom", 100, odometria);//Suscripción al topic de la odometría del robot
	ros::Subscriber sub1 = n.subscribe("/mobile_base/events/bumper", 100, sensor_choque);//Suscripción al topic del sensor de choque
	vel_pub_=np.advertise<geometry_msgs::Twist>("cmd_vel_mux/input/teleop", 1);//Variable para publicar la velocidad	
	ros::Rate loop_rate(50); //Frecuencia de realización del bucle while.	
	ros::Time ahora; // variable de tipo tiempo para almacenar el instante de tiempo.

	/*********************Se recoge la posición inicial que tiene el robot*********************************/
	ahora=ros::Time::now();	
	while(ros::Time::now()<ahora + ros::Duration(0.5))
	{
		ros::spinOnce();// Comprueba el topic de odometria para establecer la posicion inicial que tiene el robot
	}
	
	posicion_inicial.pose.pose.orientation.z=posicion_actual.pose.pose.orientation.z;
	posicion_inicial.pose.pose.position.x=posicion_actual.pose.pose.position.x;
	posicion_inicial.pose.pose.position.y=posicion_actual.pose.pose.position.y;

	/*******************Se ajusta el sentido de giro en función del ángulo a girar************************************************/
	vel.linear.x=datos_recibidos.vel_linear;
	vel.angular.z=datos_recibidos.vel_angular;
	if( datos_recibidos.angulo_rotacion<0.f)
	{
		vel.angular.z=-vel.angular.z;
	}
	/******************Se establece el ángulo que se desea alcanzar y hace un ajuste **********************************************/
	angulo_deseado=datos_recibidos.angulo_rotacion+orientacion_actual;
	if (angulo_deseado>360.f)
	{
	   angulo_deseado=((angulo_deseado/360)-1)*360;
	}
	else if (angulo_deseado<0.f)
	{
	   angulo_deseado=360+angulo_deseado;
	}
	
	/*******************Mientras no se alcance el ángulo, que siga girando el robot*********************************************/
	float error_abs=1000;
	float error;
	while(error_abs>=0.05)
	{
		ros::spinOnce();
		/****Calculo del error entre el angulo deseado y el angulo actual***********************/
		error=angulo_deseado-orientacion_actual; 
		error_abs=error;
		if (error_abs<0.f)
			error_abs=-error_abs;
		/**************Ajuste para cuando el giro pase por origen (pase de 360º a 0º o viceversa)******************/
		if(angulo_deseado<=40 && orientacion_actual>=300)
		{
			error_abs=error+360;
			error=error_abs;
		}
		if(angulo_deseado>=300 && orientacion_actual<=40)
		{
			error_abs=error-360;
			error=error_abs;
			error_abs=-error_abs;
		}
		/*************************************************/
		if (error_abs<=80 && error_abs>3)
		{
			//Control proporcional
			if (error<0.f)
				vel.angular.z=-(error_abs*0.015)-0.045;
			else
				vel.angular.z=(error_abs*0.015)+0.045;
		}
		
		else if (error_abs<=3)//1.5
		{
			if (error<0.f)
			vel.angular.z=-0.09;//0.05
			else
			vel.angular.z=0.09;
		}
		else if (error_abs==1000)
		{
			//Caso para la primera vez que arranca el programa
		}
		else
		{
			if(datos_recibidos.angulo_rotacion<0.f)
				vel.angular.z=-0.8;
			else
				vel.angular.z=0.8;
		}
		//Ajuste de velocidad máxima, nunca más de 0.8 
		if (vel.angular.z>=0.8)
			vel.angular.z=0.8;
		if (vel.angular.z<=-0.8)
			vel.angular.z=-0.8;

		if(flag_parada==1)
		{
			flag_parada=0;
			break; //Finaliza el bucle puesto que ha ocurrrido un choque
		}
		vel_pub_.publish(vel);
	}
	printf("Error: %.3f, Error real:%.3f \n",error_abs,angulo_deseado-orientacion_actual);
	ahora=ros::Time::now();	
	while(ros::Time::now()<ahora + ros::Duration(0.2))
	{
	vel.angular.z=0;
	vel_pub_.publish(vel);
	}
	ahora=ros::Time::now();	
	while(ros::Time::now()<ahora + ros::Duration(0.5))
	{
		ros::spinOnce();
	}
	
	result.orientacion_actual=float(orientacion_actual);
	result.pos_actual_x=float(posicion_actual.pose.pose.position.x);
	result.pos_actual_y=float(posicion_actual.pose.pose.position.y);
	return &result;
	
}

int *
checkbumpersemsorstate_1_svc(void *argp, struct svc_req *rqstp)
{
	static int  result;
	ros::NodeHandle p;
	ros::Subscriber sub = p.subscribe("/mobile_base/sensors/core", 100, bumper_sensor);
	ros::Rate loop_rate(10);
	ros::Time ahora;
	ahora=ros::Time::now();	

	while(ros::Time::now()<ahora + ros::Duration(0.5))
	{
		ros::spinOnce();
	}
	result=int(check_bumper_sensor.bumper);

	return &result;
}

float *
readbaterylevel_1_svc(void *argp, struct svc_req *rqstp)
{
	static float  result;

	/*ros::NodeHandle bl;
  	ros ::Subscriber sub = bl.subscribe("/diagnostics", 1000, nivel_bateria);//Suscripción al topic de la odometría del robot
  	ros::Rate loop_rate(10); //Frecuencia de realización del bucle while.	
  	ros::Time ahora; // variable de tipo tiempo para almacenar el instante de tiempo.
  	ahora=ros::Time::now();	
	while(ros::Time::now()<ahora + ros::Duration(1.3))
	{
		ros::spinOnce();
	}
	result=bateryLevel;*/
	return &result;
}

int *
checkchargin_1_svc(void *argp, struct svc_req *rqstp)
{
	static int  result;

	ros::NodeHandle bl;
  	ros ::Subscriber sub = bl.subscribe("/diagnostics", 1000, nivel_bateria);//Suscripción al topic de la odometría del robot
  	ros::Rate loop_rate(10); //Frecuencia de realización del bucle while.	
  	ros::Time ahora; // variable de tipo tiempo para almacenar el instante de tiempo.
  	ahora=ros::Time::now();	
	while(ros::Time::now()<ahora + ros::Duration(1.3))
	{
		ros::spinOnce();
	}
	result=chargerState;

	return &result;
}

int *
autodocking_1_svc(void *argp, struct svc_req *rqstp)
{
    /*Launch a client who interacts with dock server for charge the robot*/
	static int  result;

    ros::NodeHandle n_autodock;
    actionlib::SimpleActionClient<kobuki_msgs::AutoDockingAction> ac("dock_drive_action", true);

    if(ac.waitForServer(ros::Duration(AUTODOCK_SERVER_TIMEOUT)))//Check if the server is up
    {
        //The server is OK
        std::cout<<"Autodock server OK"<<std::endl;
    }
    else
    {
        // The server is down.
        std::cout<<"ERROR: Autodock Server Fail"<<std::endl;
        result=-1;
        return &result;//return the error to PLEXIL, who will wake the server with this code error.
    }

    kobuki_msgs::AutoDockingGoal goal;
    ac.sendGoal(goal);// Send Goal for start Autodock

    //Wait for the action to return
    if (ac.waitForResult(ros::Duration(AUTODOCK_DRIVE_TIMEOUT)))
    {
        actionlib::SimpleClientGoalState state = ac.getState();
        std::cout<<"Dock Finished: "<<state.toString().c_str()<<std::endl;
        result=0;
    }
    else
    {
        std::cout<<"Action did not finish before the time out."<<std::endl;
        result=-2;
    }
	return &result;
    
}





int *
takepicture_1_svc(void *argp, struct svc_req *rqstp)
{
  static int  result;
  ros::NodeHandle nh;
  image_transport::ImageTransport it(nh);
  /*--------------------------LINEA CAMBIADA PArA EL SIMULADOR--------------------------------------------*/
  image_transport::Subscriber sub = it.subscribe("/camera/rgb/image_raw", 1, imageCallback);// Topic oroginal: "/camera/rgb/image_color"
  while(!stopCapture)
  {
  ros::spinOnce();
  }
  stopCapture= false;
  if (numberOfPicture==-1) //Error has ocurred at save.
	result=0;
  else
	result=1;

   return &result;
}

RESULTADO *
checkposition_1_svc(void *argp, struct svc_req *rqstp)
{
	static RESULTADO  result;
	ros::NodeHandle nc;	
	ros::Subscriber sub = nc.subscribe("/odom", 100, odometria);//Suscripción al topic de la odometría del robot
	ros::Rate loop_rate(10); //Frecuencia de realización del bucle while.	
  	ros::Time ahora; // variable de tipo tiempo para almacenar el instante de tiempo.
  	ahora=ros::Time::now();	
	while(ros::Time::now()<ahora + ros::Duration(0.5))
	{
		ros::spinOnce();// Comprueba el topic de odometria para establecer la posicion inicial que tiene el robot
	}
	result.orientacion_actual=float(orientacion_actual);
	result.pos_actual_x=float(posicion_actual.pose.pose.position.x);
	result.pos_actual_y=float(posicion_actual.pose.pose.position.y);
	return &result;
}
int *
stopaction_1_svc(char *argp, struct svc_req *rqstp)
{
 	static int  result;

	/*
	 * insert server code here
	 */

	return &result;
}
int *
restartdockserver_1_svc(void *argp, struct svc_req *rqstp)
{
	/* This function wakes Dock Server. It will duplicate the orginal process for launch Dock Server*/
	static int  result;
    char bash[8];
    char prog[45];
    pid_t pid;
    int pid2=0;
    extern char **var_env;

    strcpy(bash,"/bin/sh"); //Bash location
    strcpy(prog,"roslaunch kobuki_auto_docking minimal.launch");// Dock server aplication

        pid=fork();
        if (pid==0)
        {
            //Child process
            if (DEBUG)
            {
                std::cout<<"I enter into child process"<<std::endl;
                std::cout<<"Child`s PID: "<<getpid()<<std::endl;
            }
            pid2=execlp(bash,bash,"-c",prog,NULL);// Launch Dock Server Station
            perror("Fails Dock server execution");
        }
        else if (pid>0)
        {
            //Father process
            if (DEBUG)
            {
            std::cout<<"I enter into father process"<<std::endl;
            std::cout<<"Father`s PID: "<<getpid()<<std::endl;
            }
            // Father process continues.
            if (pid2==-1)
            {
                //Child execution fails
                result=-1;
            }
            else
            {
            result=0;
            }
            return &result; //Return results to PLEXIL
        }
        else
        {
            //Fork failed
            std::cout<<"Error, fork failed"<<std::endl;
            result=-1;
            return &result;
        }
}

int *
stopautodock_1_svc(void *argp, struct svc_req *rqstp)
{
	static int  result;
    std::cout<<"Stop Dock Action"<<std::endl;

    ros::Publisher stop_pub;
    ros::NodeHandle n;
    actionlib_msgs::GoalID goal;
    ros::Time ahora;
    ros::Rate loop_rate(10);

    goal.stamp=ros::Time::now(); // Set time at message to send.
    stop_pub=n.advertise<actionlib_msgs::GoalID>("/dock_drive_action/cancel", 1); //Topic to send the information.
    ahora=ros::Time::now();

    while(ros::Time::now()<ahora+ros::Duration(0.3))
    {
        stop_pub.publish(goal);
        if(!stop_pub)
        {
            // Error at publish in the topic
            std::cout<<"ERROR: Cancel Dock"<<std::endl;
            result=-1;
            break;
        }
        else
        {
            //all ok
            result=0;
        }
    }
	return &result;
}
